<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>ULTIMATE CHESS</title>
    <style>
        body {
            margin: 0; background: #222; font-family: 'Segoe UI', sans-serif;
            display: flex; justify-content: center; align-items: center; height: 100vh;
            color: white; user-select: none; overflow: hidden;
        }

        /* --- –ú–ï–ù–Æ --- */
        #menu {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(30, 30, 30, 0.98); z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }
        h1 { font-size: 50px; margin: 0 0 20px 0; color: #f1c40f; letter-spacing: 5px; text-transform: uppercase; }

        .top-row { display:flex; gap:12px; align-items:center; }

        .auth-box {
            background: #2b2b2b; padding: 12px 16px; border-radius: 8px; margin-bottom: 14px;
            display: flex; gap: 10px; align-items: center; border: 1px solid #444;
        }
        .auth-box input { padding:6px 8px; border-radius:4px; border:1px solid #555; background:#222; color:white }
        .auth-box button { padding:8px 10px; border-radius:4px; border:none; cursor:pointer }

        .settings-box {
            background: #333; padding: 20px; border-radius: 10px; width: 300px;
            display: flex; flex-direction: column; gap: 15px; border: 1px solid #555;
        }
        .setting-row { display: flex; justify-content: space-between; align-items: center; }
        label { font-size: 16px; cursor: pointer; }
        input[type="checkbox"] { transform: scale(1.2); cursor: pointer; }
        input[type="range"] { width: 100px; cursor: pointer; }

        .btn-start {
            margin-top: 20px; padding: 15px 40px; font-size: 22px; 
            background: #27ae60; color: white; border: none; border-radius: 5px;
            cursor: pointer; transition: 0.2s; font-weight: bold; width: 100%;
        }
        .btn-start:hover { background: #2ecc71; transform: scale(1.02); }

        /* --- Players panel --- */
        .players-panel {
            position: absolute; left: 12px; top: 12px; width: 220px; background: rgba(20,20,20,0.95);
            border:1px solid #444; padding: 10px; border-radius: 8px; color:#ddd; z-index:200;
            display: none; flex-direction: column; gap:8px;
        }
        .players-panel h3 { margin:0 0 6px 0; font-size:14px; color:#f1c40f }
        .player-item { padding:6px; background:#222; border-radius:6px; display:flex; justify-content:space-between; align-items:center }

        /* --- –ò–ì–†–ê --- */
        #game-area { display: none; flex-direction: column; align-items: center; width: 100%; height: 100%; }
        
        .chessboard {
            display: grid; 
            /* Grid template –∑–∞–¥–∞–µ—Ç—Å—è —á–µ—Ä–µ–∑ JS */
            border: 5px solid #555; margin-top: 10px;
            background: #111;
        }

        .cell {
            display: flex; justify-content: center; align-items: center;
            font-size: 35px; cursor: pointer; position: relative;
        }
        /* –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–π —Ä–∞–∑–º–µ—Ä —à—Ä–∏—Ñ—Ç–∞ */
        .cell.small-font { font-size: 20px !important; }

        .white-cell { background-color: #cfd8dc; color: black; }
        .black-cell { background-color: #546e7a; color: white; }
        
        .selected { background-color: #f39c12 !important; }
        .last-move { background-color: #f1c40f !important; opacity: 0.8; }
        
        .dot {
            width: 30%; height: 30%; background: rgba(0,0,0,0.3);
            border-radius: 50%; position: absolute; pointer-events: none;
        }
        .capture-ring {
            width: 80%; height: 80%; border: 3px solid rgba(192, 57, 43, 0.7);
            border-radius: 50%; position: absolute; pointer-events: none;
        }

        /* –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä –∂–∏–∑–Ω–µ–π */
        .hp-indicator {
            position: absolute; bottom: 2px; right: 2px;
            font-size: 10px; background: red; color: white;
            padding: 1px 3px; border-radius: 3px; line-height: 1;
        }

        #ui-panel {
            margin-top: 10px; display: flex; gap: 20px; align-items: center;
            background: #333; padding: 10px 20px; border-radius: 8px;
        }
        .turn-indicator { font-size: 20px; font-weight: bold; }

        /* Fog / Blind mode */
        .fog { background: #000 !important; color: #000 !important; cursor: default !important; }

        /* Room UI inside menu */
        .room-box { background:#2d2d2d; padding:10px; border-radius:8px; margin-top:10px; border:1px solid #444; width:300px; display:flex; flex-direction:column; gap:8px }
        .room-box input { padding:6px; border-radius:4px; border:1px solid #555; background:#222; color:white }
        .room-box button { padding:8px; border-radius:4px; border:none; cursor:pointer }

        /* prettier piece visuals */
        .piece { font-size: 36px; filter: drop-shadow(0 2px 2px rgba(0,0,0,.6)); }
        .piece.special { font-size: 30px; }

        /* play again button */
        .play-again { padding:8px 12px; border-radius:6px; background:#2980b9; border:none; cursor:pointer; color:white }

    </style>
</head>
<body>

<div class="players-panel" id="players-panel">
    <h3>–ò–≥—Ä–æ–∫–∏</h3>
    <div id="players-list"></div>
    <div id="room-actions" style="display:flex;gap:6px;margin-top:8px">
        <button id="start-room-btn" style="flex:1">–ù–∞—á–∞—Ç—å –∏–≥—Ä—É</button>
        <button id="leave-room-btn" style="flex:1">–ü–æ–∫–∏–Ω—É—Ç—å</button>
    </div>
</div>

<div id="menu">
    <h1>–®–∞—Ö–º–∞—Ç—ã 2.0</h1>

    <!-- AUTH / REGISTRATION TOP -->
    <div class="auth-box">
        <input id="login-username" placeholder="–õ–æ–≥–∏–Ω" />
        <input id="login-password" placeholder="–ü–∞—Ä–æ–ª—å" type="password" />
        <button id="register-btn">–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è</button>
        <button id="login-btn">–í—Ö–æ–¥</button>
    </div>

    <div class="settings-box" id="settings-box">
        <div class="setting-row">
            <label for="opt-king">‚ò†Ô∏è –°–º–µ—Ä—Ç—å –ö–æ—Ä–æ–ª—è = –ö–æ–Ω–µ—Ü</label>
            <input type="checkbox" id="opt-king" checked>
        </div>
        <div class="setting-row">
            <label for="opt-board">üåç –ë–æ–ª—å—à–∞—è –¥–æ—Å–∫–∞ (16x16)</label>
            <input type="checkbox" id="opt-board">
        </div>
        <div class="setting-row">
            <label for="opt-special">ü¶Ñ –û—Å–æ–±—ã–µ —Ñ–∏–≥—É—Ä—ã</label>
            <input type="checkbox" id="opt-special">
        </div>
        <div class="setting-row">
            <label for="opt-blind">üåë –†–µ–∂–∏–º —Å–ª–µ–ø–æ—Ç—ã (—Ç—É–º–∞–Ω –≤–æ–π–Ω—ã)</label>
            <input type="checkbox" id="opt-blind">
        </div>
        <div class="setting-row" id="ai-row">
            <label>üß† –ò–Ω—Ç–µ–ª–ª–µ–∫—Ç –ò–ò: <span id="ai-val">5</span></label>
            <input type="range" id="opt-ai" min="1" max="10" value="5" oninput="document.getElementById('ai-val').innerText=this.value">
        </div>
        <button class="btn-start" id="play-local-white">–ò–ì–†–ê–¢–¨ (–ë–µ–ª—ã–µ)</button>
        <button class="btn-start" style="background:#8e44ad" id="play-local-black">–ò–ì–†–ê–¢–¨ (–ß–µ—Ä–Ω—ã–µ)</button>
    </div>

    <!-- ROOM CREATION / JOIN -->
    <div class="room-box">
        <input id="room-name" placeholder="–ò–º—è –∫–æ–º–Ω–∞—Ç—ã" />
        <div style="display:flex; gap:8px;">
            <button id="create-room-btn">–°–æ–∑–¥–∞—Ç—å –∫–æ–º–Ω–∞—Ç—É</button>
            <button id="join-room-btn">–ü—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è</button>
        </div>
        <small style="color:#bbb">–ü—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏/–≤—Ö–æ–¥–µ —Ç—Ä–µ–±—É–µ—Ç—Å—è –±—ã—Ç—å –∑–∞–ª–æ–≥–∏–Ω–µ–Ω—ã–º (–ª–æ–≥–∏–Ω/–ø–∞—Ä–æ–ª—å —Å–≤–µ—Ä—Ö—É). –õ–æ–≥–∏–Ω –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –∫–∞–∫ –∏–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.</small>
    </div>

</div>

<div id="game-area">
    <div class="chessboard" id="board"></div>
    <div id="ui-panel">
        <div class="turn-indicator" id="status-text">–•–æ–¥ –±–µ–ª—ã—Ö</div>
        <button onclick="location.reload()" style="padding:5px 10px; cursor:pointer;">–ú–µ–Ω—é</button>
    </div>
</div>

<!-- FIREBASE (module) -->
<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js";
    import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-auth.js";
    import { getDatabase, ref, set, get, onValue, child, update } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-database.js";

    const firebaseConfig = {
      apiKey: "AIzaSyC2kE0eAffr3S7tnax0Ym9int4MvNlucg4",
      authDomain: "nouneimlist.firebaseapp.com",
      databaseURL: "https://nouneimlist-default-rtdb.firebaseio.com",
      projectId: "nouneimlist",
      storageBucket: "nouneimlist.firebasestorage.app",
      messagingSenderId: "871712258235",
      appId: "1:871712258235:web:982874240dd587d749119e"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getDatabase(app);

    const EMAIL_DOMAIN = '@ultimatechess.local';

    window.registerUser = async (username, password) => {
        if (!username || !password) throw new Error('–õ–æ–≥–∏–Ω –∏ –ø–∞—Ä–æ–ª—å –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã');
        const email = username + EMAIL_DOMAIN;
        const cred = await createUserWithEmailAndPassword(auth, email, password);
        return cred.user;
    };

    window.loginUser = async (username, password) => {
        if (!username || !password) throw new Error('–õ–æ–≥–∏–Ω –∏ –ø–∞—Ä–æ–ª—å –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã');
        const email = username + EMAIL_DOMAIN;
        const cred = await signInWithEmailAndPassword(auth, email, password);
        return cred.user;
    };

    // create room with settings and add owner to players
    window.createRoom = async (roomName, settings) => {
        if (!auth.currentUser) throw new Error('–¢—Ä–µ–±—É–µ—Ç—Å—è –≤—Ö–æ–¥ –≤ —Å–∏—Å—Ç–µ–º—É');
        if (!roomName) throw new Error('–ò–º—è –∫–æ–º–Ω–∞—Ç—ã –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ');
        const key = encodeURIComponent(roomName);
        const ownerName = auth.currentUser.email ? auth.currentUser.email.split('@')[0] : 'anon';
        const roomRef = ref(db, 'rooms/' + key);
        await set(roomRef, {
            name: roomName,
            ownerUid: auth.currentUser.uid,
            ownerName: ownerName,
            createdAt: Date.now(),
            settings: settings || {},
            players: { [auth.currentUser.uid]: { name: ownerName } },
            state: { started: false }
        });
        return key;
    };

    window.joinRoom = async (roomName) => {
        if (!auth.currentUser) throw new Error('–¢—Ä–µ–±—É–µ—Ç—Å—è –≤—Ö–æ–¥ –≤ —Å–∏—Å—Ç–µ–º—É');
        if (!roomName) throw new Error('–ò–º—è –∫–æ–º–Ω–∞—Ç—ã –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ');
        const key = encodeURIComponent(roomName);
        const snap = await get(ref(db, 'rooms/' + key));
        if (!snap.exists()) throw new Error('–ö–æ–º–Ω–∞—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞');
        const playerName = auth.currentUser.email ? auth.currentUser.email.split('@')[0] : 'anon';
        await set(ref(db, 'rooms/' + key + '/players/' + auth.currentUser.uid), { name: playerName });
        return snap.val();
    };

    onAuthStateChanged(auth, user => {
        window.currentUser = user || null;
        const input = document.getElementById('login-username');
        if (user) {
            try { input.value = user.email.split('@')[0]; } catch(e) {}
        }
    });

</script>

<script>
    // --- –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø ---
    const config = {
        boardSize: 8,
        kingDeathEnds: true,
        specialPieces: false,
        aiLevel: 5,
        blindMode: false
    };

    let board = [];
    let turn = 'w';
    let playerColor = 'w';
    let selectedIndex = null;
    let possibleMoves = [];
    let gameOver = false;

    // room state
    let currentRoomKey = null;
    let isRoomHost = false;
    let isRoomGame = false;
    let localRevealed = new Set();

    const icons = { p: '‚ôü', r: '‚ôú', n: '‚ôû', b: '‚ôù', q: '‚ôõ', k: '‚ôö', s: 'üõ°Ô∏è', w: 'üß±', z: '‚ö°', c: '‚öîÔ∏è' };
    const whiteIcons = { p:'‚ôô', r:'‚ôñ', n:'‚ôò', b:'‚ôó', q:'‚ôï', k:'‚ôî', s:'üõ°Ô∏è', w:'üß±', z:'‚ö°', c:'‚öîÔ∏è' };

    // bind local play buttons
    document.getElementById('play-local-white').addEventListener('click', () => initGame('w', false));
    document.getElementById('play-local-black').addEventListener('click', () => initGame('b', false));

    // --- Room UI elements ---
    const playersPanel = document.getElementById('players-panel');
    const playersListEl = document.getElementById('players-list');
    const startRoomBtn = document.getElementById('start-room-btn');
    const leaveRoomBtn = document.getElementById('leave-room-btn');

    document.getElementById('create-room-btn').addEventListener('click', async () => {
        const rn = document.getElementById('room-name').value.trim();
        try {
            const settings = captureSettings();
            const key = await window.createRoom(rn, settings);
            currentRoomKey = key;
            isRoomHost = true;
            openRoomPanel();
            listenRoom(key);
            alert('–ö–æ–º–Ω–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∞: ' + rn);
        } catch (e) { alert('–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∫–æ–º–Ω–∞—Ç—ã: ' + e.message); }
    });

    document.getElementById('join-room-btn').addEventListener('click', async () => {
        const rn = document.getElementById('room-name').value.trim();
        try {
            const data = await window.joinRoom(rn);
            const key = encodeURIComponent(rn);
            currentRoomKey = key;
            isRoomHost = (window.currentUser && window.currentUser.uid === data.ownerUid);
            openRoomPanel();
            listenRoom(key);
            alert('–í—Ö–æ–¥ –≤ –∫–æ–º–Ω–∞—Ç—É: ' + rn);
        } catch (e) { alert('–û—à–∏–±–∫–∞ –≤—Ö–æ–¥–∞ –≤ –∫–æ–º–Ω–∞—Ç—É: ' + e.message); }
    });

    leaveRoomBtn.addEventListener('click', async () => {
        if (!currentRoomKey || !window.currentUser) return;
        try {
            // remove player
            await window.firebaseRemovePlayer?.(currentRoomKey, window.currentUser.uid);
        } catch(e){}
        closeRoomPanel();
    });

    startRoomBtn.addEventListener('click', async () => {
        if (!currentRoomKey) return;
        try {
            await startRoomGame(currentRoomKey);
        } catch(e) { alert('–û—à–∏–±–∫–∞ —Å—Ç–∞—Ä—Ç–∞: '+e.message); }
    });

    // Small helper - capture settings currently selected in UI
    function captureSettings() {
        return {
            kingDeathEnds: document.getElementById('opt-king').checked,
            boardSize: document.getElementById('opt-board').checked ? 16 : 8,
            specialPieces: document.getElementById('opt-special').checked,
            blindMode: document.getElementById('opt-blind').checked,
            aiLevel: parseInt(document.getElementById('opt-ai').value)
        };
    }

    function openRoomPanel() {
        playersPanel.style.display = 'flex';
        // hide AI row (room games are player vs player)
        document.getElementById('ai-row').style.display = 'none';
    }
    function closeRoomPanel() {
        playersPanel.style.display = 'none';
        currentRoomKey = null; isRoomHost = false; isRoomGame = false; localRevealed.clear();
        document.getElementById('ai-row').style.display = '';
    }

    // listenRoom: set onValue listener to update players list and react to start
    async function listenRoom(key) {
        const db = window.firebaseDatabase || window.db;
        const roomRef = window.dbRef ? window.dbRef('rooms/'+key) : null;
        // instead of complicated indirection, use firebase globals from earlier script
        const { ref, onValue, get } = window.__firebase_db_helpers__ || {}; // fallback
        // We'll use the db global functions via window (the module exposed db variable earlier)
        const r = window.db ? window.ref(window.db, 'rooms/' + key) : null;
        if (!r) return;
        onValue(r, snap => {
            const data = snap.val();
            // update players list
            playersListEl.innerHTML = '';
            const players = data && data.players ? data.players : {};
            const uids = Object.keys(players);
            uids.forEach(uid => {
                const name = players[uid].name || 'anon';
                const color = players[uid].color || '';
                const div = document.createElement('div');
                div.className = 'player-item';
                div.innerHTML = `<span>${name}</span><small>${color ? color.toUpperCase() : ''}</small>`;
                playersListEl.appendChild(div);
            });

            // if game started remotely -> start game locally with settings and assigned colors
            if (data && data.state && data.state.started) {
                isRoomGame = true;
                // apply settings
                if (data.settings) applySettingsFromRoom(data.settings);
                // set playerColor according to assignment
                if (window.currentUser && data.players && data.players[window.currentUser.uid]) {
                    const assigned = data.players[window.currentUser.uid].color;
                    if (assigned) playerColor = assigned;
                }
                // hide menu and show board
                document.getElementById('menu').style.display = 'none';
                document.getElementById('game-area').style.display = 'flex';
                // initialize board according to settings
                createStartBoard();
                turn = data.state.turn || 'w';
                renderBoard();
            }

            // if players <2 and host -> show start button disabled, else enabled for host
            if (isRoomHost) {
                startRoomBtn.disabled = (uids.length < 2);
            }
        });
    }

    function applySettingsFromRoom(settings) {
        try {
            document.getElementById('opt-king').checked = !!settings.kingDeathEnds;
            document.getElementById('opt-board').checked = (settings.boardSize === 16);
            document.getElementById('opt-special').checked = !!settings.specialPieces;
            document.getElementById('opt-blind').checked = !!settings.blindMode;
            document.getElementById('opt-ai').value = settings.aiLevel || 5;
            document.getElementById('ai-val').innerText = settings.aiLevel || 5;
            config.kingDeathEnds = !!settings.kingDeathEnds;
            config.boardSize = settings.boardSize || 8;
            config.specialPieces = !!settings.specialPieces;
            config.blindMode = !!settings.blindMode;
            config.aiLevel = settings.aiLevel || 5;
        } catch(e){}
    }

    // startRoomGame: only host should call - assigns colors randomly and sets started flag
    async function startRoomGame(key) {
        if (!window.currentUser) throw new Error('–ù—É–∂–Ω–æ –≤–æ–π—Ç–∏');
        // read room players
        const snap = await window.get(window.ref(window.db, 'rooms/' + key));
        if (!snap.exists()) throw new Error('–ö–æ–º–Ω–∞—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞');
        const data = snap.val();
        const players = data.players || {};
        const uids = Object.keys(players);
        if (uids.length < 2) throw new Error('–ù—É–∂–Ω–æ –º–∏–Ω–∏–º—É–º 2 –∏–≥—Ä–æ–∫–∞');
        // pick two first uids as players
        const p1 = uids[0];
        const p2 = uids[1];
        // random assignment
        const flip = Math.random() < 0.5;
        const assign = {};
        assign[p1] = { name: players[p1].name, color: flip ? 'w' : 'b' };
        assign[p2] = { name: players[p2].name, color: flip ? 'b' : 'w' };
        // write back assignments and started flag
        await window.set(window.ref(window.db, 'rooms/' + key + '/players'), assign);
        await window.set(window.ref(window.db, 'rooms/' + key + '/state'), { started: true, turn: 'w' });
    }

    // helper to remove player when leaving
    window.firebaseRemovePlayer = async (roomKey, uid) => {
        await window.set(window.ref(window.db, 'rooms/' + roomKey + '/players/' + uid), null);
    };

    // --- –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –ò –û–¢–†–ò–°–û–í–ö–ê ---
    function initGame(color, fromRoom = false) {
        // read settings
        config.kingDeathEnds = document.getElementById('opt-king').checked;
        config.boardSize = document.getElementById('opt-board').checked ? 16 : 8;
        config.specialPieces = document.getElementById('opt-special').checked;
        config.aiLevel = parseInt(document.getElementById('opt-ai').value);
        config.blindMode = document.getElementById('opt-blind').checked;

        playerColor = color;

        // grid
        const boardEl = document.getElementById('board');
        const cellSize = config.boardSize === 16 ? 35 : 70;
        boardEl.style.gridTemplateColumns = `repeat(${config.boardSize}, ${cellSize}px)`;
        boardEl.style.gridTemplateRows = `repeat(${config.boardSize}, ${cellSize}px)`;

        createStartBoard();

        document.getElementById('menu').style.display = 'none';
        document.getElementById('game-area').style.display = 'flex';

        turn = 'w';
        gameOver = false;
        localRevealed.clear();
        renderBoard();

        // when local game (no room) then AI may play
        if (!fromRoom && playerColor !== null && playerColor !== undefined) {
            if (playerColor === 'b') setTimeout(aiTurn, 500);
        }
    }

    function createStartBoard() {
        board = new Array(config.boardSize * config.boardSize).fill(null);
        const s = config.boardSize;
        const mk = (t, c, hp=1) => ({ type: t, color: c, hp: hp });
        const backRow = ['r','n','b','q','k','b','n','r'];
        let row1, row2;
        if (s === 16) {
            row1 = ['r','n','b','r','n','b','q','k','q','b','n','r','b','n','r','w'];
            row2 = new Array(16).fill('p');
        } else {
            row1 = [...backRow];
            row2 = new Array(8).fill('p');
        }

        if (config.specialPieces) {
            if (s === 8) {
                row2[0] = 's'; row2[7] = 's'; row2[3] = 'w'; row2[4] = 'w';
                row1[1] = 'z'; row1[6] = 'c';
            } else {
                row2[0]='s'; row2[1]='s'; row2[14]='s'; row2[15]='s';
                row1[0]='z'; row1[15]='c';
                row2[7]='w'; row2[8]='w';
            }
        }

        const s16 = s;
        for(let i=0; i<s16; i++) {
            if(row1[i]) board[i] = mk(row1[i], 'b', getHP(row1[i]));
            if(row2[i]) board[i + s16] = mk(row2[i], 'b', getHP(row2[i]));
        }
        for(let i=0; i<s16; i++) {
            if(row2[i]) board[s16*(s16-2) + i] = mk(row2[i], 'w', getHP(row2[i]));
            if(row1[i]) board[s16*(s16-1) + i] = mk(row1[i], 'w', getHP(row1[i]));
        }
    }

    function getHP(type) { if (type === 's') return 2; if (type === 'w') return 3; return 1; }

    function renderBoard() {
        const boardEl = document.getElementById('board');
        boardEl.innerHTML = '';
        const s = config.boardSize;

        // visible by fog: union of revealed (persistent) and current piece vision
        const visibleSet = new Set([...localRevealed]);

        if (config.blindMode) {
            for (let i = 0; i < board.length; i++) {
                const p = board[i];
                if (p && p.color === playerColor) {
                    const rr = Math.floor(i / s);
                    const cc = i % s;
                    for (let dr = -1; dr <= 1; dr++) for (let dc = -1; dc <= 1; dc++) {
                        const nr = rr + dr; const nc = cc + dc;
                        if (nr >= 0 && nr < s && nc >= 0 && nc < s) visibleSet.add(nr * s + nc);
                    }
                }
            }
        }

        // If in room, push newly visible to server (as revealed map)
        if (currentRoomKey && window.currentUser) {
            // compute new ones
            const newOnes = [];
            visibleSet.forEach(i => { if (!localRevealed.has(i)) newOnes.push(i); });
            if (newOnes.length > 0) {
                // write each index under rooms/<key>/revealed/<index> = true
                newOnes.forEach(idx => {
                    window.set(window.ref(window.db, 'rooms/' + currentRoomKey + '/revealed/' + idx), true).catch(()=>{});
                    localRevealed.add(idx);
                });
            }
        }

        for (let i = 0; i < s * s; i++) {
            const cell = document.createElement('div');
            let vIdx = playerColor === 'w' ? i : (s*s - 1 - i);
            let piece = board[vIdx];
            let row = Math.floor(vIdx / s);
            let col = vIdx % s;
            cell.className = `cell ${(row + col) % 2 === 0 ? 'white-cell' : 'black-cell'}`;
            if (s === 16) cell.classList.add('small-font');

            cell.onclick = () => {
                if (config.blindMode && !visibleSet.has(vIdx)) return;
                onCellClick(vIdx);
            };

            if (config.blindMode && !visibleSet.has(vIdx)) {
                cell.classList.add('fog');
            } else {
                if (piece) {
                    let ico = piece.color === 'w' ? whiteIcons[piece.type] : icons[piece.type];
                    cell.innerHTML = `<span class="piece ${piece.type !== 'p' ? 'special' : ''}">${ico}</span>`;
                    if (piece.hp > 1) {
                        const hp = document.createElement('div'); hp.className = 'hp-indicator'; hp.innerText = piece.hp; cell.appendChild(hp);
                    }
                }

                if (selectedIndex === vIdx) cell.classList.add('selected');
                if (possibleMoves.includes(vIdx)) {
                    const mark = document.createElement('div');
                    let isAttack = board[vIdx] && board[vIdx].color !== turn;
                    mark.className = isAttack ? 'capture-ring' : 'dot';
                    cell.appendChild(mark);
                }
            }

            boardEl.appendChild(cell);
        }

        document.getElementById('status-text').innerText = gameOver ? "–ò–ì–†–ê –û–ö–û–ù–ß–ï–ù–ê" : (turn === 'w' ? "–•–æ–¥ –ë–µ–ª—ã—Ö" : "–•–æ–¥ –ß–µ—Ä–Ω—ã—Ö");
    }

    // --- –õ–û–ì–ò–ö–ê ---
    function onCellClick(idx) {
        if (gameOver) return;
        // if room game, ensure turn and ownership
        if (isRoomGame && window.currentUser) {
            // room state should define whose turn - we'll read from DB when moves are made by owner
        }

        if (turn !== playerColor && (!isRoomGame)) return; // in local game only player's color acts

        if (possibleMoves.includes(idx)) { doMove(selectedIndex, idx); return; }

        if (board[idx] && board[idx].color === turn) {
            selectedIndex = idx; possibleMoves = getMoves(idx, board); renderBoard();
        } else {
            selectedIndex = null; possibleMoves = []; renderBoard();
        }
    }

    function doMove(from, to, isAI = false) {
        const attacker = board[from];
        const target = board[to];
        if (!attacker) return;
        let moveEnd = true;
        if (target) {
            if (target.hp > 1) { target.hp -= 1; moveEnd = false; }
            else { if (config.kingDeathEnds && target.type === 'k') { gameOver = true; alert(`–ö–æ—Ä–æ–ª—å ${target.color === 'w' ? '–ë–µ–ª—ã—Ö' : '–ß–µ—Ä–Ω—ã—Ö'} –ø–∞–ª! –ü–æ–±–µ–¥–∞ ${attacker.color === 'w' ? '–ë–µ–ª—ã—Ö' : '–ß–µ—Ä–Ω—ã—Ö'}!`); } }
        }

        if (moveEnd) { board[to] = attacker; board[from] = null; checkPromotion(to, isAI); }

        selectedIndex = null; possibleMoves = [];

        if (!gameOver) {
            turn = turn === 'w' ? 'b' : 'w';
            renderBoard();
            // if room game - push move to room state so other client can update (basic sync)
            if (currentRoomKey && window.currentUser) {
                // naive approach: write board snapshot to DB (not optimal but simple)
                // convert board to minimal serializable form
                const serial = {};
                board.forEach((p, idx) => { if (p) serial[idx] = p; });
                window.set(window.ref(window.db, 'rooms/' + currentRoomKey + '/boardSnapshot'), serial).catch(()=>{});
                // update turn
                window.set(window.ref(window.db, 'rooms/' + currentRoomKey + '/state/turn'), turn).catch(()=>{});
            }

            // AI turn for local games
            if (!isRoomGame && turn !== playerColor) { setTimeout(aiTurn, 100); }
        } else { renderBoard(); }
    }

    function checkPromotion(idx, isAI) { const p = board[idx]; if (!p || p.type !== 'p') return; const s = config.boardSize; const row = Math.floor(idx / s); const endRow = p.color === 'w' ? 0 : s - 1; if (row === endRow) { if (isAI) p.type = 'q'; else { let newType = prompt("–ü—Ä–µ–≤—Ä–∞—â–µ–Ω–∏–µ! –í–≤–µ–¥–∏—Ç–µ –±—É–∫–≤—É: q (–§–µ—Ä–∑—å), n (–ö–æ–Ω—å), r (–õ–∞–¥—å—è), b (–°–ª–æ–Ω), w (–°—Ç–µ–Ω–∞)", "q"); const map = {'q':'q', 'n':'n', 'r':'r', 'b':'b', 'w':'w', 's':'s'}; p.type = map[newType && newType.toLowerCase()] || 'q'; } } }

    // --- –ì–ï–ù–ï–†–ê–¢–û–† –•–û–î–û–í (–∏–∑–º–µ–Ω–µ–Ω–∏—è: wall horizontal slide, commander 3x3, zigzag infinite) ---
    function getMoves(idx, bd) {
        const piece = bd[idx]; if (!piece) return [];
        const moves = []; const s = config.boardSize; const r = Math.floor(idx / s); const c = idx % s;
        const add = (nr, nc) => { if (nr >= 0 && nr < s && nc >= 0 && nc < s) { const tIdx = nr * s + nc; const target = bd[tIdx]; if (!target) { moves.push(tIdx); return true; } else if (target.color !== piece.color) { moves.push(tIdx); return false; } else return false; } return false; };
        const slide = (dr, dc, limit = 99) => { for (let k = 1; k <= limit; k++) { if (!add(r + dr * k, c + dc * k)) break; } };

        switch (piece.type) {
            case 'p': {
                let d = piece.color === 'w' ? -1 : 1;
                let startR = piece.color === 'w' ? s-2 : 1;
                if (r+d >=0 && r+d < s && !bd[(r+d)*s + c]) { moves.push((r+d)*s + c); if (r === startR && !bd[(r+d*2)*s + c]) moves.push((r+d*2)*s + c); }
                if(c>0 && bd[(r+d)*s + c-1] && bd[(r+d)*s + c-1].color !== piece.color) moves.push((r+d)*s + c-1);
                if(c<s-1 && bd[(r+d)*s + c+1] && bd[(r+d)*s + c+1].color !== piece.color) moves.push((r+d)*s + c+1);
                break;
            }
            case 's': {
                let d2 = piece.color === 'w' ? -1 : 1;
                if (r+d2 >=0 && r+d2 < s && !bd[(r+d2)*s + c]) moves.push((r+d2)*s + c);
                if(c>0 && bd[(r+d2)*s + c-1] && bd[(r+d2)*s + c-1].color !== piece.color) moves.push((r+d2)*s + c-1);
                if(c<s-1 && bd[(r+d2)*s + c+1] && bd[(r+d2)*s + c+1].color !== piece.color) moves.push((r+d2)*s + c+1);
                break;
            }
            case 'n': [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]].forEach(([dr,dc])=>add(r+dr,c+dc)); break;
            case 'b': [[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([dr,dc])=>slide(dr,dc)); break;
            case 'r': [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dr,dc])=>slide(dr,dc)); break;
            case 'q': [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([dr,dc])=>slide(dr,dc)); break;
            case 'k': [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([dr,dc])=>add(r+dr,c+dc)); break;

            // wall: can slide horizontally infinitely now
            case 'w': [[0,1],[0,-1]].forEach(([dr,dc])=>slide(dr,dc)); break;

            // zigzag: diagonal jumps of 2 repeated (infinite) + short orthogonal
            case 'z': {
                // diagonal jumps every 2
                for (let k = 1; k <= 8; k++) {
                    add(r + 2*k, c + 2*k);
                    add(r + 2*k, c - 2*k);
                    add(r - 2*k, c + 2*k);
                    add(r - 2*k, c - 2*k);
                }
                // short orthogonal
                [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dr,dc]) => add(r+dr,c+dc));
                break;
            }

            // commander: expand to 3x3 (all neighbors)
            case 'c': for (let dr=-1; dr<=1; dr++) for (let dc=-1; dc<=1; dc++) if (!(dr===0 && dc===0)) add(r+dr,c+dc); break;

        }
        return moves;
    }

    // --- AI ---
    function aiTurn() {
        if (gameOver) return;
        const aiColor = playerColor === 'w' ? 'b' : 'w';
        let allMoves = [];
        for(let i=0;i<board.length;i++) if (board[i] && board[i].color === aiColor) { let mvs = getMoves(i, board); mvs.forEach(to=>allMoves.push({from:i,to:to})); }
        if (allMoves.length===0) return;
        let chosen = null;

        // difficulty mapping: 1 very easy (random bad), 5 hard (greedy+small lookahead), 10 impossible (deep candidate eval)
        if (config.aiLevel <= 1) {
            // deliberately poor: prefer moves that capture nothing and move to low-value squares
            const shuffled = allMoves.sort(()=>0.5-Math.random());
            chosen = shuffled[0];
        } else if (config.aiLevel <= 5) {
            // greedy but with small lookahead
            allMoves.sort((a,b)=>{ let va = board[a.to]?getPieceValue(board[a.to].type):0; let vb = board[b.to]?getPieceValue(board[b.to].type):0; return vb-va; });
            chosen = allMoves[0];
            if (Math.random() < 0.15) chosen = allMoves[Math.floor(Math.random()*Math.min(4,allMoves.length))];
        } else {
            // stronger: candidate sampling + one-ply simulation with heuristic
            let bestScore = -Infinity;
            const candidates = allMoves.length>80 ? allMoves.sort(()=>0.5-Math.random()).slice(0,80) : allMoves;
            candidates.forEach(m => {
                const savedTo = board[m.to];
                const savedFrom = board[m.from];
                let score = 0;
                if (savedTo) score += getPieceValue(savedTo.type)*10;
                // simulate
                board[m.to] = savedFrom; board[m.from] = null;
                // evaluate basic material
                let mat=0; for(let i=0;i<board.length;i++) if (board[i]) mat += (board[i].color===aiColor?1:-1)*getPieceValue(board[i].type);
                score += mat;
                // restore
                board[m.from]=savedFrom; board[m.to]=savedTo;
                // random tie-breaker
                score += Math.random()*2;
                if (score>bestScore) { bestScore=score; chosen=m; }
            });
        }

        if (chosen) doMove(chosen.from, chosen.to, true);
    }

    function getPieceValue(t) { const vals = { p:10, s:15, z:25, c:25, n:30, b:30, r:50, w:60, q:90, k:900 }; return vals[t]||0; }

    // --- Sync: listen for boardSnapshot and revealed updates for room games ---
    function startRoomSync(key) {
        if (!key) return;
        const bsRef = window.ref(window.db, 'rooms/' + key + '/boardSnapshot');
        const revRef = window.ref(window.db, 'rooms/' + key + '/revealed');
        window.onValue(bsRef, snap => {
            const serial = snap.val();
            if (!serial) return;
            // apply snapshot
            board = new Array(config.boardSize*config.boardSize).fill(null);
            Object.keys(serial).forEach(k => board[parseInt(k)] = serial[k]);
            renderBoard();
        });
        window.onValue(revRef, snap => {
            const data = snap.val()||{};
            Object.keys(data).forEach(k=>localRevealed.add(parseInt(k)));
            renderBoard();
        });
    }

    // --- BIND MENU ACTIONS FOR AUTH/ROOMS (–¥–æ–±–∞–≤–ª–µ–Ω–æ) ---
    document.getElementById('register-btn').addEventListener('click', async () => {
        const u = document.getElementById('login-username').value.trim();
        const p = document.getElementById('login-password').value;
        try { await window.registerUser(u,p); alert('–ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω –∏ –≤–æ—à—ë–ª: '+u); } catch(e){ alert('–û—à–∏–±–∫–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏: '+e.message); }
    });
    document.getElementById('login-btn').addEventListener('click', async () => {
        const u = document.getElementById('login-username').value.trim();
        const p = document.getElementById('login-password').value;
        try { await window.loginUser(u,p); alert('–í—Ö–æ–¥ –≤—ã–ø–æ–ª–Ω–µ–Ω: '+u); } catch(e){ alert('–û—à–∏–±–∫–∞ –≤—Ö–æ–¥–∞: '+e.message); }
    });

    // expose helpers for firebase global access
    window.db = window.db || (window.db = window.db || (function(){ try { return window.__db || window.db; } catch(e){ return null; } })());
    // but earlier module created `db` in module scope not in window; the module exposes get/set/ref/onValue via window already in created script
    // To ensure functions like window.ref/window.set exist, we attach them here using the module script's functions
    // (the previous module created functions in its own scope; if they are not available this area will fail silently)

    // done

</script>
</body>
</html>





